/*
 * Panasonic MN88472 DVB-T/T2/C demodulator driver
 *
 * Copyright (C) 2013 Antti Palosaari <crope@iki.fi>
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 */

#include "mn88472_priv.h"

static struct dvb_frontend_ops mn88472_ops_c;

#define T2 (0x38>>1)
#define T1 (0x30>>1)
#define C1 (0x34>>1)

struct nm88472_i2c_reg_byte {
	u8 i2c_bank;
	u8 addr;
	u8  val;
};

static const struct nm88472_i2c_reg_byte demod_bank_init[] = {
{T2,0x00,0x66},{T2,0x01,0x00},{T2,0x02,0x01},{T2,0x03,0x03},
{T2,0x04,0x00},{T2,0x05,0x00},{T2,0x06,0x00},{T2,0x07,0x00},
{T2,0x08,0x00},{T2,0x09,0x00},{T2,0x0a,0x00},{T2,0x0b,0x00},
{T2,0x0c,0x00},{T2,0x0d,0x00},{T2,0x0e,0x00},{T2,0x0f,0x00},
{T2,0x10,0x3e},{T2,0x11,0x70},{T2,0x12,0x64},{T2,0x13,0x8f},
{T2,0x14,0x80},{T2,0x15,0x00},{T2,0x16,0x08},{T2,0x17,0xee},
{T2,0x18,0x08},{T2,0x19,0xee},{T2,0x1a,0x43},{T2,0x1b,0x00},
{T2,0x1c,0x74},{T2,0x1d,0xe4},{T2,0x1e,0x26},{T2,0x1f,0x4f},
{T2,0x20,0x72},{T2,0x21,0x22},{T2,0x22,0x22},{T2,0x23,0x01},
{T2,0x24,0x00},{T2,0x25,0x12},{T2,0x26,0x00},{T2,0x27,0x00},
{T2,0x28,0x80},{T2,0x29,0x0c},{T2,0x2a,0xf4},{T2,0x2b,0x03},
{T2,0x2c,0x00},{T2,0x2d,0x20},{T2,0x2e,0x88},{T2,0x2f,0x00},
{T2,0x30,0x80},{T2,0x31,0x80},{T2,0x32,0x00},{T2,0x33,0x00},
{T2,0x34,0x00},{T2,0x35,0x00},{T2,0x36,0x00},{T2,0x37,0x00},
{T2,0x38,0xca},{T2,0x39,0x03},{T2,0x3a,0x02},{T2,0x3b,0x55},
{T2,0x3c,0xd7},{T2,0x3d,0x00},{T2,0x3e,0x00},{T2,0x3f,0x22},
{T2,0x40,0x00},{T2,0x41,0x38},{T2,0x42,0x22},{T2,0x43,0x00},
{T2,0x44,0x38},{T2,0x45,0xd3},{T2,0x46,0x10},{T2,0x47,0xb5},
{T2,0x48,0xa1},{T2,0x49,0x00},{T2,0x4a,0xd3},{T2,0x4b,0x07},
{T2,0x4c,0x64},{T2,0x4d,0x0d},{T2,0x4e,0x00},{T2,0x4f,0x05},
{T2,0x50,0x00},{T2,0x51,0x55},{T2,0x52,0x20},{T2,0x53,0x00},
{T2,0x54,0x24},{T2,0x55,0x64},{T2,0x56,0x44},{T2,0x57,0x33},
{T2,0x58,0x1f},{T2,0x59,0x00},{T2,0x5a,0x5a},{T2,0x5b,0x03},
{T2,0x5c,0xc0},{T2,0x5d,0x00},{T2,0x5e,0x00},{T2,0x5f,0x03},
{T2,0x60,0x00},{T2,0x61,0x00},{T2,0x62,0x11},{T2,0x63,0x40},
{T2,0x64,0x84},{T2,0x65,0x04},{T2,0x66,0x0c},{T2,0x67,0x00},
{T2,0x68,0x08},{T2,0x69,0x00},{T2,0x6a,0x00},{T2,0x6b,0x12},
{T2,0x6c,0x21},{T2,0x6d,0x10},{T2,0x6e,0x01},{T2,0x6f,0x00},
{T2,0x70,0x00},{T2,0x71,0x00},{T2,0x72,0xe8},{T2,0x73,0x48},
{T2,0x74,0x40},{T2,0x75,0x00},{T2,0x76,0x1d},{T2,0x77,0x19},
{T2,0x78,0x1d},{T2,0x79,0x19},{T2,0x7a,0x66},{T2,0x7b,0x8c},
{T2,0x7c,0x9f},{T2,0x7d,0x08},{T2,0x7e,0x00},{T2,0x7f,0x00},
{T2,0x80,0x00},{T2,0x81,0x00},{T2,0x83,0x00},{T2,0x84,0x00},
{T2,0x85,0x00},{T2,0x86,0x00},{T2,0x87,0x00},{T2,0x88,0x00},
{T2,0x89,0x00},{T2,0x8a,0x20},{T2,0x8b,0x49},{T2,0x8c,0x00},
{T2,0xc4,0x00},{T2,0xc5,0x00},{T2,0xc6,0x00},{T2,0xc7,0x87},
{T2,0xc8,0x40},{T2,0xc9,0x30},{T2,0xca,0x06},{T2,0xcb,0x02},
{T2,0xcc,0x00},{T2,0xcd,0x3b},{T2,0xce,0x00},{T2,0xcf,0x00},
{T2,0xd0,0x00},{T2,0xd1,0x00},{T2,0xd2,0x00},{T2,0xd3,0x40},
{T2,0xd4,0x00},{T2,0xd5,0xf0},{T2,0xd6,0x02},{T2,0xd7,0x02},
{T2,0xd8,0x01},{T2,0xd9,0x00},{T2,0xda,0x00},{T2,0xdb,0x00},
{T2,0xdc,0x00},{T2,0xdd,0x00},{T2,0xde,0x00},{T2,0xdf,0x00},
{T2,0xe0,0x00},{T2,0xe1,0x00},{T2,0xe2,0x00},{T2,0xe3,0x00},
{T2,0xe4,0x00},{T2,0xe5,0x00},{T2,0xe6,0x00},{T2,0xe7,0x00},
{T2,0xe9,0x00},{T2,0xea,0x00},{T2,0xeb,0x00},{T2,0xec,0xd3},
{T2,0xed,0x31},{T2,0xee,0x00},{T2,0xef,0x00},{T2,0xf0,0x00},
{T2,0xf1,0x00},{T2,0xf2,0x00},{T2,0xf3,0x00},{T2,0xf4,0x00},
{T2,0xf5,0x00},{T2,0xf6,0x00},{T2,0xf8,0x9f},{T2,0xf9,0xd4},
{T2,0xfa,0x00},{T2,0xfb,0x03},{T2,0xfc,0x00},{T2,0xfd,0x00},
{T2,0xfe,0x00},{T2,0xff,0x02},{T1,0x00,0xba},{T1,0x01,0x13},
{T1,0x02,0x80},{T1,0x03,0xba},{T1,0x04,0x91},{T1,0x05,0x40},
{T1,0x06,0xe7},{T1,0x07,0x26},{T1,0x08,0xff},{T1,0x09,0x1b},
{T1,0x0a,0x09},{T1,0x0b,0x08},{T1,0x0c,0x04},{T1,0x0d,0x2d},
{T1,0x0e,0x09},{T1,0x0f,0x00},{T1,0x10,0x10},{T1,0x11,0x1f},
{T1,0x12,0x08},{T1,0x13,0x00},{T1,0x14,0x00},{T1,0x15,0x03},
{T1,0x16,0x00},{T1,0x17,0x00},{T1,0x18,0x00},{T1,0x19,0xb0},
{T1,0x1a,0x00},{T1,0x1b,0x00},{T1,0x1c,0x00},{T1,0x1d,0xe0},
{T1,0x1e,0x6c},{T1,0x1f,0x33},{T1,0x20,0x4a},{T1,0x21,0x03},
{T1,0x22,0x00},{T1,0x23,0x01},{T1,0x24,0x05},{T1,0x25,0x96},
{T1,0x26,0x43},{T1,0x27,0x00},{T1,0x28,0x01},{T1,0x29,0x15},
{T1,0x2a,0xa2},{T1,0x2b,0xc3},{T1,0x2c,0xf5},{T1,0x2d,0x22},
{T1,0x2e,0x87},{T1,0x2f,0xd3},{T1,0x30,0x00},{T1,0x31,0x55},
{T1,0x32,0x33},{T1,0x33,0x61},{T1,0x34,0x22},{T1,0x35,0x01},
{T1,0x36,0x02},{T1,0x37,0x40},{T1,0x38,0x40},{T1,0x39,0x46},
{T1,0x3a,0x25},{T1,0x3b,0x04},{T1,0x3c,0x00},{T1,0x3d,0x04},
{T1,0x3e,0x00},{T1,0x3f,0x00},{T1,0x40,0x3b},{T1,0x41,0x20},
{T1,0x42,0x00},{T1,0x43,0x3f},{T1,0x44,0x1f},{T1,0x45,0x05},
{T1,0x46,0x00},{T1,0x47,0x00},{T1,0x48,0x05},{T1,0x49,0xf0},
{T1,0x4a,0x00},{T1,0x4b,0x00},{T1,0x4c,0x1f},{T1,0x4d,0x0f},
{T1,0x4e,0x39},{T1,0x4f,0x03},{T1,0x50,0xf8},{T1,0x51,0xf4},
{T1,0x52,0x08},{T1,0x53,0xf8},{T1,0x54,0xea},{T1,0x55,0xf0},
{T1,0x56,0x04},{T1,0x57,0x20},{T1,0x58,0x12},{T1,0x59,0x12},
{T1,0x5a,0x02},{T1,0x5b,0x20},{T1,0x5c,0x1a},{T1,0x5d,0x08},
{T1,0x5e,0xad},{T1,0x5f,0x33},{T1,0x60,0x95},{T1,0x61,0x8f},
{T1,0x62,0x80},{T1,0x63,0x00},{T1,0x64,0x76},{T1,0x65,0x54},
{T1,0x66,0x87},{T1,0x67,0x65},{T1,0x68,0x66},{T1,0x69,0x54},
{T1,0x6a,0x4a},{T1,0x6b,0x86},{T1,0x6c,0x13},{T1,0x6d,0x31},
{T1,0x6e,0x2d},{T1,0x6f,0x07},{T1,0x70,0x00},{T1,0x71,0x40},
{T1,0x72,0x00},{T1,0x73,0x00},{T1,0x74,0x00},{T1,0x75,0x10},
{T1,0x76,0x0c},{T1,0x77,0x0c},{T1,0x78,0x59},{T1,0x79,0x00},
{T1,0x7a,0x00},{T1,0x7b,0x00},{T1,0x7c,0x00},{T1,0x7d,0x05},
{T1,0x88,0x1e},{T1,0x89,0x49},{T1,0x8a,0x31},{T1,0x8b,0x1a},
{T1,0x8c,0x2c},{T1,0x8d,0x3f},{T1,0x8e,0x7f},{T1,0x8f,0x07},
{T1,0xa5,0x00},{T1,0xa6,0x00},{T1,0xa9,0x00},{T1,0xaa,0x00},
{T1,0xab,0x00},{T1,0xae,0x00},{T1,0xaf,0x00},{T1,0xb0,0x0a},
{T1,0xb1,0x7a},{T1,0xb2,0x40},{T1,0xb3,0x5c},{T1,0xb4,0xf6},
{T1,0xb5,0x31},{T1,0xb6,0xc0},{T1,0xb7,0xff},{T1,0xb8,0x88},
{T1,0xb9,0xff},{T1,0xba,0xaa},{T1,0xbb,0x00},{T1,0xbc,0x08},
{T1,0xbd,0x03},{T1,0xbe,0x00},{T1,0xbf,0x00},{T1,0xc0,0xbf},
{T1,0xc1,0x00},{T1,0xc2,0x00},{T1,0xc3,0xff},{T1,0xc4,0x20},
{T1,0xc5,0x80},{T1,0xc6,0xff},{T1,0xc7,0xff},{T1,0xc8,0xff},
{T1,0xc9,0xe0},{T1,0xca,0x80},{T1,0xcb,0x00},{T1,0xcc,0x00},
{T1,0xcd,0x01},{T1,0xce,0x00},{T1,0xcf,0x54},{T1,0xd0,0x23},
{T1,0xd1,0x47},{T1,0xd2,0x01},{T1,0xd3,0x00},{T1,0xd4,0x09},
{T1,0xd5,0x47},{T1,0xd6,0x46},{T1,0xd7,0x00},{T1,0xd8,0x00},
{T1,0xd9,0xe1},{T1,0xda,0x03},{T1,0xdb,0x08},{T1,0xdc,0xb8},
{T1,0xdd,0x08},{T1,0xde,0x0c},{T1,0xdf,0x90},{T1,0xe6,0x00},
{T1,0xe7,0x00},{T1,0xe8,0x00},{T1,0xec,0x00},{T1,0xed,0x00},
{T1,0xee,0x00},{T2,0xfb,0x03},{T1,0xf0,0x00},{T1,0xf1,0x00},
{T1,0xf2,0x00},{T1,0xf3,0x00},{T1,0xf4,0x00},{T1,0xf5,0x01},
{T1,0xf7,0x00},{T1,0xf8,0x00},{T1,0xf9,0x07},{T1,0xfa,0xff},
{T1,0xfb,0x00},{T1,0xfc,0x00},{T1,0xfd,0x30},{T1,0xfe,0x00},
{T1,0xff,0x02},{C1,0x00,0xb0},{C1,0x01,0x00},{C1,0x02,0x11},
{C1,0x03,0x18},{C1,0x04,0x04},{C1,0x05,0xe0},{C1,0x06,0x5f},
{C1,0x07,0x27},{C1,0x08,0x30},{C1,0x09,0xff},{C1,0x0a,0xc0},
{C1,0x0b,0xaa},{C1,0x0c,0xbb},{C1,0x0d,0xee},{C1,0x0e,0xaa},
{C1,0x0f,0xaa},{C1,0x10,0x0d},{C1,0x11,0xab},{C1,0x12,0x0b},
{C1,0x13,0x3c},{C1,0x14,0x18},{C1,0x15,0xd9},{C1,0x16,0x51},
{C1,0x17,0xec},{C1,0x18,0x00},{C1,0x19,0xbe},{C1,0x1a,0xd6},
{C1,0x1b,0x1c},{C1,0x1c,0x0b},{C1,0x1d,0x3c},{C1,0x1e,0x29},
{C1,0x1f,0x00},{C1,0x20,0x00},{C1,0x21,0x00},{C1,0x22,0xa0},
{C1,0x23,0x94},{C1,0x24,0xaf},{C1,0x25,0x01},{C1,0x26,0x00},
{C1,0x27,0x00},{C1,0x28,0x00},{C1,0x29,0x00},{C1,0x2a,0x00},
{C1,0x2b,0x00},{C1,0x2c,0x00},{C1,0x2d,0x00},{C1,0x2e,0x00},
{C1,0x2f,0x0c},{C1,0x30,0x3b},{C1,0x31,0x41},{C1,0x32,0x0c},
{C1,0x33,0x02},{C1,0x34,0xb1},{C1,0x35,0xed},{C1,0x36,0x60},
{C1,0x37,0xcc},{C1,0x38,0x6c},{C1,0x39,0x7d},{C1,0x3a,0xb1},
{C1,0x3b,0xed},{C1,0x3c,0x69},{C1,0x3d,0xb3},{C1,0x3e,0xed},
{C1,0x3f,0x40},{C1,0x40,0xdb},{C1,0x41,0xda},{C1,0x42,0x79},
{C1,0x43,0x87},{C1,0x44,0xbc},{C1,0x45,0x3f},{C1,0x46,0xb7},
{C1,0x47,0x5e},{C1,0x48,0x1c},{C1,0x49,0xb7},{C1,0x4a,0x56},
{C1,0x4b,0xb7},{C1,0x4c,0x56},{C1,0x4d,0xb7},{C1,0x4e,0x56},
{C1,0x4f,0x63},{C1,0x50,0xd5},{C1,0x51,0x74},{C1,0x52,0x95},
{C1,0x53,0x5f},{C1,0x54,0xc0},{C1,0x55,0x73},{C1,0x56,0x28},
{C1,0x57,0xc4},{C1,0x58,0x69},{C1,0x59,0x55},{C1,0x5a,0x55},
{C1,0x5b,0x40},{C1,0x5c,0x60},{C1,0x5d,0xfd},{C1,0x5e,0x00},
{C1,0x5f,0x00},{C1,0x60,0x30},{C1,0x61,0x29},{C1,0x62,0x13},
{C1,0x63,0xf0},{C1,0x64,0x00},{C1,0x65,0x96},{C1,0x66,0x72},
{C1,0x67,0x1b},{C1,0x68,0x2d},{C1,0x69,0x97},{C1,0x6a,0x4b},
{C1,0x6b,0xde},{C1,0x6c,0x88},{C1,0x6d,0x00},{C1,0x6e,0x00},
{C1,0x6f,0x00},{C1,0x70,0xab},{C1,0x71,0x2b},{C1,0x72,0x10},
{C1,0x73,0xf4},{C1,0x74,0x47},{C1,0x75,0x57},{C1,0x76,0x40},
{C1,0x77,0xaa},{C1,0x78,0xaa},{C1,0x79,0x01},{C1,0x7a,0x00},
{C1,0x7b,0x07},{C1,0x7c,0x50},{C1,0x80,0x00},{C1,0x81,0x88},
{C1,0x82,0x00},{C1,0xf0,0x00},{C1,0xf1,0x5e},{C1,0xf2,0xec},
{C1,0xf3,0x00},{C1,0xf4,0x5e},{C1,0xf5,0xec},{C1,0xf6,0x05},
{T2,0xfb,0x03},{C1,0xfc,0x00},{C1,0xfd,0x00},{C1,0xfe,0x00},
{C1,0xff,0x02},
};


/* write multiple registers */
static int mn88472_wregs(struct mn88472_state *s, u16 reg, const u8 *val, int len)
{
#define MAX_WR_LEN 21
#define MAX_WR_XFER_LEN (MAX_WR_LEN + 1)
	int ret;
	u8 buf[MAX_WR_XFER_LEN];
	struct i2c_msg msg[1] = {
		{
			.addr = (reg >> 8) & 0xff,
			.flags = 0,
			.len = 1 + len,
			.buf = buf,
		}
	};

	if (WARN_ON(len > MAX_WR_LEN))
		return -EINVAL;

	buf[0] = (reg >> 0) & 0xff;
	memcpy(&buf[1], val, len);

	ret = i2c_transfer(s->i2c, msg, 1);
	if (ret == 1) {
		ret = 0;
	} else {
		dev_warn(&s->i2c->dev,
				"%s: i2c wr failed=%d reg=%02x len=%d\n",
				KBUILD_MODNAME, ret, reg, len);
		ret = -EREMOTEIO;
	}

	return ret;
}

/* read multiple registers */
static int mn88472_rregs(struct mn88472_state *s, u16 reg, u8 *val, int len)
{
#define MAX_RD_LEN 2
#define MAX_RD_XFER_LEN (MAX_RD_LEN)
	int ret;
	u8 buf[MAX_RD_XFER_LEN];
	struct i2c_msg msg[2] = {
		{
			.addr = (reg >> 8) & 0xff,
			.flags = 0,
			.len = 1,
			.buf = buf,
		}, {
			.addr = (reg >> 8) & 0xff,
			.flags = I2C_M_RD,
			.len = len,
			.buf = buf,
		}
	};

	if (WARN_ON(len > MAX_RD_LEN))
		return -EINVAL;

	buf[0] = (reg >> 0) & 0xff;

	ret = i2c_transfer(s->i2c, msg, 2);
	if (ret == 2) {
		memcpy(val, buf, len);
		ret = 0;
	} else {
		dev_warn(&s->i2c->dev,
				"%s: i2c rd failed=%d reg=%02x len=%d\n",
				KBUILD_MODNAME, ret, reg, len);
		ret = -EREMOTEIO;
	}

	return ret;
}

/* write single register */
static int mn88472_wreg(struct mn88472_state *s, u16 reg, u8 val)
{
	return mn88472_wregs(s, reg, &val, 1);
}

/* read single register */
static int mn88472_rreg(struct mn88472_state *s, u16 reg, u8 *val)
{
	return mn88472_rregs(s, reg, val, 1);
}

int nm88472_wr_table(struct mn88472_state *s, const struct nm88472_i2c_reg_byte* table, int tab_length)
{
	int i, ret = 0;
	for (i=0 ; i<tab_length ; i++) {
		ret |= mn88472_wreg(s, (table[i].i2c_bank<<8)| table[i].addr, table[i].val);
//		msleep(20);
	}
	return ret;
}


static int mn88472_get_tune_settings(struct dvb_frontend *fe,
	struct dvb_frontend_tune_settings *s)
{
	s->min_delay_ms = 400;
	return 0;
}

static int mn88472_set_frontend_c(struct dvb_frontend *fe)
{
	struct mn88472_state *s = fe->demodulator_priv;
	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
	int ret;
	u8 u8tmp;
	u32 if_frequency = 0;
	dev_dbg(&s->i2c->dev,
			"%s: delivery_system=%d modulation=%d frequency=%d symbol_rate=%d inversion=%d\n",
			__func__, c->delivery_system, c->modulation,
			c->frequency, c->symbol_rate, c->inversion);

	if (!s->warm) {
		ret = -EAGAIN;
		goto err;
	}

	/* program tuner */
	if (fe->ops.tuner_ops.set_params) {
		ret = fe->ops.tuner_ops.set_params(fe);
		if (ret)
			goto err;
	}

	if (fe->ops.tuner_ops.get_if_frequency) {
		ret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);
		if (ret)
			goto err;

		dev_dbg(&s->i2c->dev, "%s: get_if_frequency=%d\n",
				__func__, if_frequency);
	}

// 	if (if_frequency != 5070000) {
// 		dev_err(&s->i2c->dev, "%s: IF frequency %d not supported\n",
// 				KBUILD_MODNAME, if_frequency);
// 		ret = -EINVAL;
// 		goto err;
// 	}

ret = mn88472_wregs(s, 0x1c08, "\x1d", 1); // generated
// 006242:  OUT: 000002 ms 074889 ms 40 00 30 00 10 06 02 00 >>>  d9 e3
ret = mn88472_wregs(s, 0x18d9, "\xe3", 1); // generated


ret = mn88472_wregs(s, 0x1c83, "\x01", 1); // generated
	if (ret)
		goto err;
ret = mn88472_wregs(s, 0x1c05, "\x00", 1); // generated
	if (ret)
		goto err;
	// 007979:  OUT: 000002 ms 080123 ms 40 00 38 00 10 06 02 00 >>>  0b 00
ret = mn88472_wregs(s, 0x1c0b, "\x00", 1); // generated
	if (ret)
		goto err;// 007980:  OUT: 000003 ms 080125 ms 40 00 38 00 10 06 02 00 >>>  0c 00
ret = mn88472_wregs(s, 0x1c0c, "\x00", 1); // generated
	if (ret)
		goto err;// 007981:  OUT: 000002 ms 080128 ms 40 00 38 00 10 06 02 00 >>>  ff 00
ret = mn88472_wregs(s, 0x1cff, "\x00", 1); // generated
	if (ret)
		goto err;
	// 007982:  OUT: 000002 ms 080130 ms 40 00 38 00 10 06 02 00 >>>  00 66
ret = mn88472_wregs(s, 0x1c00, "\x66", 1); // generated
	if (ret)
		goto err;
// 007983:  OUT: 000003 ms 080132 ms 40 00 38 00 10 06 02 00 >>>  01 00
ret = mn88472_wregs(s, 0x1c01, "\x00", 1); // generated
	if (ret)
		goto err;
// 007984:  OUT: 000002 ms 080135 ms 40 00 38 00 10 06 02 00 >>>  02 01
ret = mn88472_wregs(s, 0x1c02, "\x01", 1); // generated
	if (ret)
		goto err;
// 007985:  OUT: 000002 ms 080137 ms 40 00 38 00 10 06 02 00 >>>  03 02
ret = mn88472_wregs(s, 0x1c03, "\x02", 1); // generated
	if (ret)
		goto err;
// 007986:  OUT: 000003 ms 080139 ms 40 00 38 00 10 06 02 00 >>>  04 00
ret = mn88472_wregs(s, 0x1c04, "\x00", 1); // generated
	if (ret)
		goto err;
// 007987:  OUT: 000002 ms 080142 ms 40 00 38 00 10 06 02 00 >>>  10 39
ret = mn88472_wregs(s, 0x1c10, "\x39", 1); // generated
	if (ret)
		goto err;
// 007988:  OUT: 000003 ms 080144 ms 40 00 38 00 10 06 02 00 >>>  11 11
ret = mn88472_wregs(s, 0x1c11, "\x11", 1); // generated
	if (ret)
		goto err;
// 007989:  OUT: 000002 ms 080147 ms 40 00 38 00 10 06 02 00 >>>  12 bc
ret = mn88472_wregs(s, 0x1c12, "\xbc", 1); // generated
	if (ret)
		goto err;
// 007990:  OUT: 000002 ms 080149 ms 40 00 38 00 10 06 02 00 >>>  13 8f
ret = mn88472_wregs(s, 0x1c13, "\x8f", 1); // generated
	if (ret)
		goto err;
// 007991:  OUT: 000003 ms 080151 ms 40 00 38 00 10 06 02 00 >>>  14 80
ret = mn88472_wregs(s, 0x1c14, "\x80", 1); // generated
	if (ret)
		goto err;
// 007992:  OUT: 000002 ms 080154 ms 40 00 38 00 10 06 02 00 >>>  15 00
ret = mn88472_wregs(s, 0x1c15, "\x00", 1); // generated
	if (ret)
		goto err;
// 007993:  OUT: 000002 ms 080156 ms 40 00 38 00 10 06 02 00 >>>  16 08
ret = mn88472_wregs(s, 0x1c16, "\x08", 1); // generated
	if (ret)
		goto err;
// 007994:  OUT: 000003 ms 080158 ms 40 00 38 00 10 06 02 00 >>>  17 ee
ret = mn88472_wregs(s, 0x1c17, "\xee", 1); // generated
	if (ret)
		goto err;
// 007995:  OUT: 000002 ms 080161 ms 40 00 38 00 10 06 02 00 >>>  18 08
ret = mn88472_wregs(s, 0x1c18, "\x08", 1); // generated
	if (ret)
		goto err;
// 007996:  OUT: 000002 ms 080163 ms 40 00 38 00 10 06 02 00 >>>  19 ee
ret = mn88472_wregs(s, 0x1c19, "\xee", 1); // generated
	if (ret)
		goto err;
// 007997:  OUT: 000003 ms 080165 ms 40 00 30 00 10 06 02 00 >>>  46 00
ret = mn88472_wregs(s, 0x1846, "\x00", 1); // generated
	if (ret)
		goto err;
// 007998:  OUT: 000002 ms 080168 ms 40 00 30 00 10 06 02 00 >>>  ae 00
ret = mn88472_wregs(s, 0x18ae, "\x00", 1); // generated
	if (ret)
		goto err;
// 007999:  OUT: 000002 ms 080170 ms 40 00 30 00 10 06 02 00 >>>  b0 0a
ret = mn88472_wregs(s, 0x18b0, "\x0a", 1); // generated
	if (ret)
		goto err;
// 008000:  OUT: 000003 ms 080172 ms 40 00 30 00 10 06 02 00 >>>  b4 00
ret = mn88472_wregs(s, 0x18b4, "\x00", 1); // generated
	if (ret)
		goto err;
// 008001:  OUT: 000003 ms 080175 ms 40 00 30 00 10 06 02 00 >>>  cd 1f
ret = mn88472_wregs(s, 0x18cd, "\x1f", 1); // generated
	if (ret)
		goto err;
// 008002:  OUT: 000003 ms 080178 ms 40 00 30 00 10 06 02 00 >>>  d4 0a
ret = mn88472_wregs(s, 0x18d4, "\x0a", 1); // generated
	if (ret)
		goto err;
// 008003:  OUT: 000002 ms 080181 ms 40 00 30 00 10 06 02 00 >>>  d6 48
ret = mn88472_wregs(s, 0x18d6, "\x48", 1); // generated
	if (ret)
		goto err;
// 008004:  OUT: 000002 ms 080183 ms 40 00 30 00 10 06 02 00 >>>  00 ba
ret = mn88472_wregs(s, 0x1800, "\xba", 1); // generated
	if (ret)
		goto err;
// 008005:  OUT: 000003 ms 080185 ms 40 00 30 00 10 06 02 00 >>>  01 13
ret = mn88472_wregs(s, 0x1801, "\x13", 1); // generated
	if (ret)
		goto err;
// 008006:  OUT: 000002 ms 080188 ms 40 00 30 00 10 06 01 00 >>>  16
ret = mn88472_rreg(s, 0x1816, &u8tmp); // generated
	if (ret)
		goto err;
// 008007:  OUT: 000002 ms 080190 ms c0 00 30 00 00 06 01 00 <<<  00
// 008008:  OUT: 000003 ms 080192 ms 40 00 30 00 10 06 02 00 >>>  16 00
ret = mn88472_wregs(s, 0x1816, "\x00", 1); // generated
	if (ret)
		goto err;
// 008009:  OUT: 000002 ms 080195 ms 40 00 38 00 10 06 02 00 >>>  f8 9f
ret = mn88472_wregs(s, 0x1cf8, "\x9f", 1); // generated
	if (ret)
		goto err;

	s->delivery_system = c->delivery_system;

	return 0;
err:
	dev_dbg(&s->i2c->dev, "%s: failed=%d\n", __func__, ret);
	return ret;
}

static int mn88472_read_status_c(struct dvb_frontend *fe, fe_status_t *status)
{
	struct mn88472_state *s = fe->demodulator_priv;
	int ret;
	u8 u8tmp;

	*status = 0;

	if (!s->warm) {
		ret = -EAGAIN;
		goto err;
	}
		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
				FE_HAS_SYNC | FE_HAS_LOCK;
	ret = mn88472_wregs(s, 0x1c83, "\x01", 1); // generated
	if (ret)
		goto err;	
	ret = mn88472_rreg(s, 0x187f, &u8tmp);
	if (ret)
		goto err;
	ret = mn88472_rreg(s, 0x1c8e, &u8tmp);
	if (ret)
		goto err;
	dev_dbg(&s->i2c->dev,
			"%s: status=0x%x\n",
			__func__, u8tmp);
	
	if ((u8tmp&0x0F) > 8)
		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |
				FE_HAS_SYNC | FE_HAS_LOCK;

	return 0;
err:
	dev_dbg(&s->i2c->dev, "%s: failed=%d\n", __func__, ret);
	return ret;
}

static int mn88472_init_c(struct dvb_frontend *fe)
{
	struct mn88472_state *s = fe->demodulator_priv;
	int ret, len, remaining;
	const struct firmware *fw = NULL;
	u8 *fw_file = MN88472_FIRMWARE;
	dev_dbg(&s->i2c->dev, "%s:\n", __func__);

// 	if (s->warm == true)
// 		return 0;

	/* set cold state by default */
	s->warm = false;

	/* power on */
	ret = mn88472_wreg(s, 0x1c05, 0x00);
	if (ret)
		goto err;

	ret = mn88472_wregs(s, 0x1c0b, "\x00\x00", 2);
	if (ret)
		goto err;

	/* Load init tables */
	
	ret = nm88472_wr_table(s, demod_bank_init, ARRAY_SIZE(demod_bank_init));
	if (ret)
		goto err;
	
	
	/* request the firmware, this will block and timeout */
	ret = request_firmware(&fw, fw_file, s->i2c->dev.parent);
	if (ret) {
		dev_err(&s->i2c->dev, "%s: firmare file '%s' not found\n",
				KBUILD_MODNAME, fw_file);
		goto err;
	}

	dev_info(&s->i2c->dev, "%s: downloading firmware from file '%s'\n",
			KBUILD_MODNAME, fw_file);

	ret = mn88472_wreg(s, 0x18f5, 0x03);
	if (ret)
		goto err;

	for (remaining = fw->size; remaining > 0;
			remaining -= (s->cfg->i2c_wr_max - 1)) {
		len = remaining;
		if (len > (s->cfg->i2c_wr_max - 1))
			len = (s->cfg->i2c_wr_max - 1);

		ret = mn88472_wregs(s, 0x18f6,
				&fw->data[fw->size - remaining], len);
		if (ret) {
			dev_err(&s->i2c->dev,
					"%s: firmware download failed=%d\n",
					KBUILD_MODNAME, ret);
			goto err;
		}
	}

	ret = mn88472_wreg(s, 0x18f5, 0x00);
	if (ret)
		goto err;

	release_firmware(fw);
	fw = NULL;

	/* warm state */
	s->warm = true;

	return 0;
err:
	if (fw)
		release_firmware(fw);

	dev_dbg(&s->i2c->dev, "%s: failed=%d\n", __func__, ret);
	return ret;
}

static int mn88472_sleep_c(struct dvb_frontend *fe)
{
	struct mn88472_state *s = fe->demodulator_priv;
	int ret;
	dev_dbg(&s->i2c->dev, "%s:\n", __func__);

	return 0;
	/* power off */
	ret = mn88472_wreg(s, 0x1c0b, 0x30);
	if (ret)
		goto err;

	ret = mn88472_wreg(s, 0x1c05, 0x3e);
	if (ret)
		goto err;

	s->delivery_system = SYS_UNDEFINED;

	return 0;
err:
	dev_dbg(&s->i2c->dev, "%s: failed=%d\n", __func__, ret);
	return ret;
}

static void mn88472_release_c(struct dvb_frontend *fe)
{
	struct mn88472_state *s = fe->demodulator_priv;
	kfree(s);
}

struct dvb_frontend *mn88472_attach_c(const struct mn88472_c_config *cfg,
		struct i2c_adapter *i2c)
{
	int ret;
	struct mn88472_state *s;
	u8 u8tmp;
	dev_dbg(&i2c->dev, "%s:\n", __func__);

	/* allocate memory for the internal state */
	s = kzalloc(sizeof(struct mn88472_state), GFP_KERNEL);
	if (!s) {
		ret = -ENOMEM;
		dev_err(&i2c->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);
		goto err;
	}

	s->cfg = cfg;
	s->i2c = i2c;

	/* check demod responds to I2C */
	ret = mn88472_rreg(s, 0x1c00, &u8tmp);
	if (ret)
		goto err;

	/* create dvb_frontend */
	memcpy(&s->fe.ops, &mn88472_ops_c, sizeof(struct dvb_frontend_ops));
	s->fe.demodulator_priv = s;

	return &s->fe;
err:
	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);
	kfree(s);
	return NULL;
}
EXPORT_SYMBOL(mn88472_attach_c);

static struct dvb_frontend_ops mn88472_ops_c = {
	.delsys = {SYS_DVBT},
	.info = {
		.name = "Panasonic MN88472",
		.caps =	FE_CAN_FEC_1_2			|
			FE_CAN_FEC_2_3			|
			FE_CAN_FEC_3_4			|
			FE_CAN_FEC_5_6			|
			FE_CAN_FEC_7_8			|
			FE_CAN_FEC_AUTO			|
			FE_CAN_QPSK			|
			FE_CAN_QAM_16			|
			FE_CAN_QAM_32			|
			FE_CAN_QAM_64			|
			FE_CAN_QAM_128			|
			FE_CAN_QAM_256			|
			FE_CAN_QAM_AUTO			|
			FE_CAN_TRANSMISSION_MODE_AUTO	|
			FE_CAN_GUARD_INTERVAL_AUTO	|
			FE_CAN_HIERARCHY_AUTO		|
			FE_CAN_MUTE_TS			|
			FE_CAN_2G_MODULATION		|
			FE_CAN_MULTISTREAM
	},

	.release = mn88472_release_c,

	.get_tune_settings = mn88472_get_tune_settings,

	.init = mn88472_init_c,
	.sleep = mn88472_sleep_c,

	.set_frontend = mn88472_set_frontend_c,
/*	.get_frontend = mn88472_get_frontend_c, */

	.read_status = mn88472_read_status_c,
/*	.read_snr = mn88472_read_snr_c, */
};

MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
MODULE_DESCRIPTION("Panasonic MN88472 DVB-T/T2/C demodulator driver");
MODULE_LICENSE("GPL");
MODULE_FIRMWARE(MN88472_FIRMWARE);
